"""
traffic_model.py

Engineering teletraffic model for a mixed-traffic full-availability trunk group.

Scenarios:
- Incoming single-link calls (e.g., PSTN -> mobile).
- Outgoing single-link calls (with retry behavior).
- Dual-link (two-line) calls (e.g., call forwarding or 3-party bridge).

The model is inspired by classical teletraffic theory and by research on
inter-network interfaces with SS7 signaling and mixed voice traffic:

- Erlang-B blocking formula (stable recursion).
- Equivalent-load representation for dual-link (two-line) calls.
- Fixed-point iteration for repeated outgoing call attempts (retry traffic).
- Practical performance metrics: blocking, carried traffic, utilization, etc.
"""

from __future__ import annotations

from dataclasses import dataclass


def erlang_b(V: int, A: float) -> float:
    """
    Compute Erlang B blocking probability for a full-availability loss system.

    Parameters
    ----------
    V : int
        Number of trunks (circuits) in the group. Must be > 0.
    A : float
        Offered traffic load in Erlangs (non-negative).

    Returns
    -------
    float
        Blocking probability B(V, A).

    Notes
    -----
    Uses the classic stable recursion:

        B(0, A) = 1
        B(n, A) = (A * B(n-1, A)) / (n + A * B(n-1, A))

    which avoids factorials and large intermediate numbers.
    """
    if V <= 0:
        raise ValueError("V must be positive")
    if A < 0:
        raise ValueError("A must be non-negative")

    B = 1.0
    for n in range(1, V + 1):
        B = (A * B) / (n + A * B)
    return B


@dataclass
class TrunkGroupParameters:
    """
    Input parameters for the mixed-traffic trunk group model.

    All traffic values are in Erlangs and correspond to average offered
    loads over the considered period (e.g. busy hour).

    Attributes
    ----------
    V : int
        Number of trunks (circuits) in the group.
    A_in : float
        Offered traffic of incoming single-link calls (e.g. PSTN -> mobile).
    A_out : float
        Offered traffic of outgoing single-link calls (first attempts only,
        i.e. without retries).
    A_2p : float
        Offered traffic of dual-link (two-line) calls in "single-link
        equivalents" per conversation. Each such call occupies two trunks
        in the group, so internally we use A_2p_eff = 2 * A_2p.
    retry_factor : float
        Average number of additional attempts per failed outgoing call.
        Example: retry_factor = 1.0 means on average one extra attempt
        per failed call; 0.3 means 0.3 extra attempts, etc.
    pstn_block_prob : float
        Probability that a call is lost in the external PSTN / local loop
        path even if the trunk group itself has free capacity. This models
        the effect of busy resources in the remote network (e.g. local PSTN).
    """

    V: int
    A_in: float
    A_out: float
    A_2p: float
    retry_factor: float
    pstn_block_prob: float

    def validate(self) -> None:
        """Basic input validation."""
        if self.V <= 0:
            raise ValueError("V (number of trunks) must be positive")
        for name, value in [
            ("A_in", self.A_in),
            ("A_out", self.A_out),
            ("A_2p", self.A_2p),
            ("retry_factor", self.retry_factor),
            ("pstn_block_prob", self.pstn_block_prob),
        ]:
            if value < 0:
                raise ValueError(f"{name} must be non-negative")
        if not (0.0 <= self.pstn_block_prob <= 1.0):
            raise ValueError("pstn_block_prob must be in [0, 1]")


@dataclass
class TrunkGroupResults:
    """
    Output metrics of the mixed-traffic trunk group model.

    Attributes
    ----------
    A_total : float
        Total offered load to the trunk group (including retries) in Erlangs.
    blocking_prob : float
        Erlang-B blocking probability of the trunk group.
    outgoing_loss_prob : float
        End-to-end loss probability for outgoing calls (blocked in the
        trunk group or rejected in the PSTN path).
    retry_load : float
        Load in Erlangs generated by repeated outgoing calls.
    carried_traffic : float
        Carried traffic in Erlangs (A_total * (1 - blocking_prob)).
    utilization : float
        Average utilization of the trunk group, i.e. mean number of
        busy trunks divided by V.
    iterations : int
        Number of iterations in the fixed-point procedure.
    converged : bool
        True if the fixed-point iteration converged within max_iter.
    """

    A_total: float
    blocking_prob: float
    outgoing_loss_prob: float
    retry_load: float
    carried_traffic: float
    utilization: float
    iterations: int
    converged: bool


def solve_trunk_group(
    params: TrunkGroupParameters,
    tol: float = 1e-10,
    max_iter: int = 10_000,
) -> TrunkGroupResults:
    """
    Solve the mixed-traffic trunk group with retries using a fixed-point iteration.

    Algorithm (engineering approximation):

    1. Start with an initial guess for the retry load z = 0.
    2. At each iteration:
       - Compute effective dual-link traffic: A_2p_eff = 2 * A_2p.
       - Compute total offered load:
             A_total = A_in + A_2p_eff + A_out + z
       - Compute trunk blocking probability B via Erlang-B.
       - Compute end-to-end loss probability for an outgoing call:
             P_loss = 1 - (1 - B) * (1 - pstn_block_prob)
         (either blocked in the trunk group, or OK in the group but
          rejected in the external PSTN path).
       - Update retry load:
             z_new = A_out * retry_factor * P_loss
       - Stop when |z_new - z| is small enough (relative tolerance).

    3. Return the final blocking probabilities and traffic metrics.

    This is consistent with classical teletraffic methods for systems with
    repeated attempts and dual-link calls and is suitable for large trunk
    groups with mixed voice traffic.

    Parameters
    ----------
    params : TrunkGroupParameters
        Model input parameters.
    tol : float, optional
        Relative tolerance for the fixed-point convergence on z (default 1e-10).
    max_iter : int, optional
        Maximum number of iterations (default 10_000).

    Returns
    -------
    TrunkGroupResults
        Calculated performance metrics of the trunk group.
    """
    params.validate()

    V = params.V
    A_in = params.A_in
    A_out = params.A_out
    A_2p = params.A_2p
    k = params.retry_factor
    p_T = params.pstn_block_prob

    # fixed-point iteration for retry load z
    z = 0.0
    converged = False
    iterations = 0

    for i in range(1, max_iter + 1):
        A_2p_eff = 2.0 * A_2p
        A_total = A_in + A_2p_eff + A_out + z

        B = erlang_b(V, A_total)

        # Overall loss for an outgoing call:
        # blocked in the trunk group OR accepted by the group,
        # but rejected in the PSTN path.
        P_loss = 1.0 - (1.0 - B) * (1.0 - p_T)

        z_new = A_out * k * P_loss

        # Relative convergence check on z
        if abs(z_new - z) <= tol * max(1.0, abs(z_new)):
            z = z_new
            converged = True
            iterations = i
            break

        z = z_new
        iterations = i

    # Final metrics with converged (or last) z
    A_2p_eff = 2.0 * A_2p
    A_total = A_in + A_2p_eff + A_out + z
    B = erlang_b(V, A_total)
    P_loss = 1.0 - (1.0 - B) * (1.0 - p_T)
    carried = A_total * (1.0 - B)
    utilization = carried / V

    return TrunkGroupResults(
        A_total=A_total,
        blocking_prob=B,
        outgoing_loss_prob=P_loss,
        retry_load=z,
        carried_traffic=carried,
        utilization=utilization,
        iterations=iterations,
        converged=converged,
    )


if __name__ == "__main__":
    # Example scenario: large SS7/PSTN inter-network trunk group
    example_params = TrunkGroupParameters(
        V=300,          # number of trunks in the group
        A_in=50.0,      # incoming load (Erlangs)
        A_out=30.0,     # outgoing first-attempt load (Erlangs)
        A_2p=20.0,      # dual-link calls, single-link equivalent load
        retry_factor=0.3,   # average number of retries per failed outgoing call
        pstn_block_prob=0.3 # external PSTN blocking probability
    )

    results = solve_trunk_group(example_params)

    print("=== Mixed Trunk Group Results ===")
    print(f"Converged:           {results.converged}")
    print(f"Iterations:          {results.iterations}")
    print(f"Total offered A:     {results.A_total:.4f} Erlangs")
    print(f"Blocking (ErlangB):  {results.blocking_prob:.6e}")
    print(f"Outgoing loss prob:  {results.outgoing_loss_prob:.6e}")
    print(f"Retry load z*:       {results.retry_load:.4f} Erlangs")
    print(f"Carried traffic:     {results.carried_traffic:.4f} Erlangs")
    print(f"Utilization (A/V):   {results.utilization:.4f}")
